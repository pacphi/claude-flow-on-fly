name: Integration Tests

on:
  workflow_dispatch:
    inputs:
      test_region:
        description: 'Fly.io region for test deployment'
        required: false
        default: 'sea'
        type: string
      skip_cleanup:
        description: 'Skip cleanup (for debugging)'
        required: false
        default: false
        type: boolean

env:
  TEST_APP_PREFIX: "claude-ci-test"
  REGION: ${{ inputs.test_region || 'sea' }}

jobs:
  integration-test:
    name: End-to-End Integration Test
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Install Fly CLI
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Generate test app name
        id: app-name
        run: |
          # Generate unique app name with timestamp
          timestamp=$(date +%s)
          app_name="${TEST_APP_PREFIX}-${timestamp}"
          echo "app_name=$app_name" >> $GITHUB_OUTPUT
          echo "Test app name: $app_name"

      - name: Create test SSH key
        id: ssh-key
        run: |
          # Generate SSH key for testing
          ssh-keygen -t ed25519 -f test_key -N "" -C "github-actions-test"
          echo "ssh_key_created=true" >> $GITHUB_OUTPUT

          # Set proper permissions
          chmod 600 test_key
          chmod 644 test_key.pub

      - name: Prepare fly.toml for testing
        env:
          FLY_API_TOKEN: ${{ secrets.FLYIO_AUTH_TOKEN }}
          APP_NAME: ${{ steps.app-name.outputs.app_name }}
          VOLUME_NAME: "test_data"
          VOLUME_SIZE: "5"
          VM_MEMORY: "1024"
          CPU_KIND: "shared"
          CPU_COUNT: "1"
        run: |
          # Use the configuration script in CI mode to prevent port conflicts
          ./scripts/prepare-fly-config.sh --ci-mode

      - name: Deploy test environment
        env:
          # Required: FLYIO_AUTH_TOKEN secret must be configured in repository settings
          FLY_API_TOKEN: ${{ secrets.FLYIO_AUTH_TOKEN }}
        run: |
          echo "Creating Fly.io app for testing..."

          # Create app
          flyctl apps create ${{ steps.app-name.outputs.app_name }} --org personal || echo "App may already exist"

          # Create volume
          flyctl volumes create test_data \
            --app ${{ steps.app-name.outputs.app_name }} \
            --region ${REGION} \
            --size 5 \
            --no-encryption \
            --yes

          # Set SSH key as secret
          ssh_key_content=$(cat test_key.pub)
          flyctl secrets set AUTHORIZED_KEYS="$ssh_key_content" \
            --app ${{ steps.app-name.outputs.app_name }}

          # Deploy the application
          flyctl deploy --app ${{ steps.app-name.outputs.app_name }} --yes

      - name: Wait for deployment
        env:
          FLY_API_TOKEN: ${{ secrets.FLYIO_AUTH_TOKEN }}
        run: |
          echo "Waiting for deployment to be ready..."

          app_name="${{ steps.app-name.outputs.app_name }}"
          timeout=300
          elapsed=0
          interval=10
          status_check_interval=30
          last_status_log=0

          while [ $elapsed -lt $timeout ]; do
            # Get detailed status
            status_output=$(flyctl status --app $app_name 2>&1)

            # Log detailed status every 30 seconds
            if [ $((elapsed - last_status_log)) -ge $status_check_interval ]; then
              echo "=== Status Check (${elapsed}s/${timeout}s) ==="
              echo "$status_output"
              echo "=== Machine Details ==="
              flyctl machine list --app $app_name 2>&1 || echo "Failed to get machine list"
              echo "========================"
              last_status_log=$elapsed
            fi

            # Check if app is running AND started (more precise than just "running")
            if echo "$status_output" | grep -q "running" && echo "$status_output" | grep -q "started"; then
              echo "âœ… App status shows running and started"

              # Additional check: verify SSH connectivity using flyctl
              echo "Testing SSH connectivity via flyctl..."
              if timeout 15 flyctl ssh console --app $app_name --command "echo 'Health check successful'" 2>/dev/null; then
                echo "âœ… SSH connectivity verified via flyctl"
                break
              else
                echo "âš ï¸  App running but SSH not yet accessible via flyctl"
              fi
            elif echo "$status_output" | grep -q "failed\|crashed\|error"; then
              echo "âŒ App appears to have failed or crashed"
              echo "App status: $status_output"
              echo "Recent logs:"
              flyctl logs --app $app_name
              exit 1
            else
              echo "Waiting for app to start... (${elapsed}s/${timeout}s) - Current status not fully ready"
            fi

            sleep $interval
            elapsed=$((elapsed + interval))
          done

          if [ $elapsed -ge $timeout ]; then
            echo "âŒ Timeout waiting for app to be ready"
            echo "Final status:"
            flyctl status --app $app_name
            echo "Machine details:"
            flyctl machine list --app $app_name
            echo "Recent logs:"
            flyctl logs --app $app_name
            exit 1
          fi

      - name: Test SSH connectivity
        env:
          FLY_API_TOKEN: ${{ secrets.FLYIO_AUTH_TOKEN }}
        run: |
          echo "Testing SSH connectivity..."

          app_name="${{ steps.app-name.outputs.app_name }}"
          max_attempts=5
          attempt=1

          while [ $attempt -le $max_attempts ]; do
            echo "SSH attempt $attempt/$max_attempts..."

            # Test SSH connection with timeout using flyctl
            if timeout 30 flyctl ssh console --app $app_name --command "echo 'SSH connection successful' && whoami && pwd" 2>/dev/null; then
              echo "âœ… SSH connection successful"
              break
            else
              echo "âš ï¸  SSH attempt $attempt failed"
              if [ $attempt -eq $max_attempts ]; then
                echo "âŒ All SSH attempts failed"

                # Debug information
                echo "App status:"
                flyctl status --app $app_name
                echo "App logs:"
                flyctl logs --app $app_name
                exit 1
              fi

              sleep 30
            fi

            attempt=$((attempt + 1))
          done

      - name: Test VM configuration
        run: |
          echo "Testing VM configuration and tools..."

          app_name="${{ steps.app-name.outputs.app_name }}"

          # Test that configuration script exists and tools are available
          flyctl ssh console --app $app_name --command '
            echo "Testing VM environment..."

            # Check if configuration script exists
            if [ -f "/workspace/scripts/vm-configure.sh" ]; then
              echo "âœ… VM configuration script found"
            else
              echo "âŒ VM configuration script missing"
              exit 1
            fi

            # Check basic tools
            which curl || { echo "âŒ curl not found"; exit 1; }
            which git || { echo "âŒ git not found"; exit 1; }
            which ssh || { echo "âŒ ssh not found"; exit 1; }

            # Check workspace directory
            ls -la /workspace/ || { echo "âŒ workspace directory issue"; exit 1; }

            echo "âœ… Basic VM tests passed"
            '

      - name: Test volume persistence
        env:
          FLY_API_TOKEN: ${{ secrets.FLYIO_AUTH_TOKEN }}
        run: |
          echo "Testing volume persistence..."

          app_name="${{ steps.app-name.outputs.app_name }}"
          test_file="/workspace/test-persistence-$(date +%s).txt"
          test_content="integration-test-$(date +%s)"

          # Create test file
          flyctl ssh console --app $app_name --command "echo '$test_content' > $test_file && cat $test_file"

          # Restart the machine to test persistence
          machine_id=$(flyctl machine list --app $app_name --json | jq -r '.[0].id')
          flyctl machine restart $machine_id --app $app_name

          # Wait for restart
          sleep 30

          # Check file still exists
          flyctl ssh console --app $app_name --command "
            if [ -f '$test_file' ]; then
              content=\$(cat $test_file)
              if [ '\$content' = '$test_content' ]; then
                echo 'âœ… Volume persistence test passed'
              else
                echo 'âŒ File content changed'
                exit 1
              fi
            else
              echo 'âŒ Test file disappeared after restart'
              exit 1
            fi
            "

      - name: Test auto-suspend functionality
        if: success()
        env:
          FLY_API_TOKEN: ${{ secrets.FLYIO_AUTH_TOKEN }}
        run: |
          echo "Testing auto-suspend functionality..."

          app_name="${{ steps.app-name.outputs.app_name }}"

          # Check that machine can be suspended
          machine_id=$(flyctl machine list --app $app_name --json | jq -r '.[0].id')
          flyctl machine stop $machine_id --app $app_name

          # Wait for stop
          sleep 10

          # Check status
          if flyctl status --app $app_name | grep -q "stopped"; then
            echo "âœ… Auto-suspend test passed"
          else
            echo "âš ï¸  Machine did not stop as expected"
          fi

          # Start it back up for cleanup
          flyctl machine start $machine_id --app $app_name

      - name: Cleanup test resources
        if: always() && !inputs.skip_cleanup
        env:
          # Required: FLYIO_AUTH_TOKEN secret must be configured in repository settings
          FLY_API_TOKEN: ${{ secrets.FLYIO_AUTH_TOKEN }}
        run: |
          echo "Cleaning up test resources..."

          app_name="${{ steps.app-name.outputs.app_name }}"

          # Stop and destroy machines
          machines=$(flyctl machine list --app $app_name --json | jq -r '.[].id')
          for machine in $machines; do
            echo "Stopping machine $machine..."
            flyctl machine stop $machine --app $app_name || true
            sleep 5
            echo "Destroying machine $machine..."
            flyctl machine destroy $machine --app $app_name --force || true
          done

          # Destroy volumes
          volumes=$(flyctl volumes list --app $app_name --json | jq -r '.[].id')
          for volume in $volumes; do
            echo "Destroying volume $volume..."
            flyctl volumes destroy $volume --app $app_name --yes || true
          done

          # Destroy app
          echo "Destroying app $app_name..."
          flyctl apps destroy $app_name --yes || true

          # Clean up SSH key
          rm -f test_key test_key.pub

          echo "âœ… Cleanup completed"

      - name: Report test results
        if: always()
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            echo "âœ… All integration tests passed successfully"
          else
            echo "âŒ Some integration tests failed"
            echo "Check the logs above for details"
          fi

  notify-failure:
    name: Notify on Failure
    runs-on: ubuntu-latest
    needs: integration-test
    if: failure() && github.event_name == 'schedule'
    permissions:
      contents: read
      issues: write

    steps:
      - name: Create failure issue
        uses: actions/github-script@v8
        with:
          script: |
            const title = `Integration Tests Failed - ${new Date().toISOString().split('T')[0]}`;
            const body = `
            ðŸš¨ **Scheduled Integration Tests Failed**

            The daily integration tests have failed. Please investigate the following:

            - Check the [workflow run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
            - Verify Fly.io infrastructure is working
            - Check if any recent changes broke the deployment process

            **Details:**
            - Run ID: ${{ github.run_id }}
            - Triggered: ${{ github.event_name }}
            - Time: ${new Date().toISOString()}

            This issue was automatically created by the integration test workflow.
            `;

            // Check if an issue already exists for today
            const today = new Date().toISOString().split('T')[0];
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'integration-test-failure'
            });

            const existingIssue = issues.data.find(issue =>
              issue.title.includes(today) && issue.title.includes('Integration Tests Failed')
            );

            if (!existingIssue) {
              console.log(`Creating new integration test failure issue for ${today}`);
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                labels: ['bug', 'integration-test-failure', 'high-priority']
              });
            } else {
              console.log(`Integration test failure issue already exists for ${today}: #${existingIssue.number}`);
              // Add a comment to the existing issue with new failure details
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existingIssue.number,
                body: `
                ðŸ”„ **Additional Integration Test Failure**

                Another integration test run has failed today.

                **Details:**
                - Run ID: ${{ github.run_id }}
                - Time: ${new Date().toISOString()}
                - Workflow: [View Run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
                `
              });
            }