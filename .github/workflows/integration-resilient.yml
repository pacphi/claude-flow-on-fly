# Integration tests with enhanced resilience for registry failures
# This workflow includes comprehensive retry logic for all registry-dependent operations

name: Integration Tests (Resilient)

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

env:
  FLY_API_TOKEN: ${{ secrets.FLYIO_AUTH_TOKEN }}

jobs:
  integration-test:
    runs-on: ubuntu-latest
    timeout-minutes: 45

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Fly CLI
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Setup retry utilities
        id: retry-setup
        shell: bash
        run: |
          # Create comprehensive retry function
          cat > /tmp/retry_utils.sh << 'RETRY_EOF'
          #!/bin/bash

          # Generic retry with exponential backoff
          retry_with_backoff() {
            local max_attempts=${1:-3}
            local initial_delay=${2:-5}
            local max_delay=${3:-60}
            local attempt=1
            local exit_code=0

            shift 3

            while [ $attempt -le $max_attempts ]; do
              echo "‚ñ∂Ô∏è  Attempt $attempt of $max_attempts: $@"

              if "$@"; then
                echo "‚úÖ Command succeeded"
                return 0
              else
                exit_code=$?

                if [ $attempt -lt $max_attempts ]; then
                  local wait_time=$((initial_delay * attempt))
                  [ $wait_time -gt $max_delay ] && wait_time=$max_delay

                  echo "‚ö†Ô∏è  Command failed (exit: $exit_code), retrying in ${wait_time}s..."
                  sleep $wait_time
                  attempt=$((attempt + 1))
                else
                  echo "‚ùå Command failed after $max_attempts attempts (exit: $exit_code)"
                  return $exit_code
                fi
              fi
            done
          }

          # Flyctl deployment with retry
          flyctl_deploy_retry() {
            local app_name=$1
            local max_attempts=4
            local attempt=1

            while [ $attempt -le $max_attempts ]; do
              echo "‚ñ∂Ô∏è  Deployment attempt $attempt of $max_attempts for $app_name..."

              # Add timeout to prevent indefinite hangs
              if timeout 180s flyctl deploy \
                --app "$app_name" \
                --strategy immediate \
                --wait-timeout 120s \
                --yes; then
                echo "‚úÖ Deployment successful"
                return 0
              else
                local exit_code=$?

                if [ $attempt -lt $max_attempts ]; then
                  local wait_time=$((15 * attempt))
                  echo "‚ö†Ô∏è  Deployment failed (exit: $exit_code), retrying in ${wait_time}s..."

                  # Check if it's a registry issue
                  if flyctl logs -a "$app_name" 2>&1 | grep -i "registry\|pull\|image"; then
                    echo "üîç Detected potential registry issue in logs"
                  fi

                  sleep $wait_time
                  attempt=$((attempt + 1))
                else
                  echo "‚ùå Deployment failed after $max_attempts attempts"
                  echo "üìã Final logs:"
                  flyctl logs -a "$app_name" || true
                  return $exit_code
                fi
              fi
            done
          }

          # SSH command with retry
          ssh_command_retry() {
            local app_name=$1
            shift
            local command="$@"
            local max_attempts=5
            local attempt=1

            while [ $attempt -le $max_attempts ]; do
              echo "‚ñ∂Ô∏è  SSH attempt $attempt of $max_attempts..."

              if timeout 30s flyctl ssh console -a "$app_name" -C "$command"; then
                echo "‚úÖ SSH command succeeded"
                return 0
              else
                local exit_code=$?

                if [ $attempt -lt $max_attempts ]; then
                  local wait_time=$((3 * attempt))
                  echo "‚ö†Ô∏è  SSH failed (exit: $exit_code), retrying in ${wait_time}s..."
                  sleep $wait_time
                  attempt=$((attempt + 1))
                else
                  echo "‚ùå SSH command failed after $max_attempts attempts"
                  return $exit_code
                fi
              fi
            done
          }

          # Machine readiness check with retry
          wait_for_machine_ready() {
            local app_name=$1
            local max_attempts=30
            local attempt=1

            echo "‚è≥ Waiting for machine to be ready..."

            while [ $attempt -le $max_attempts ]; do
              if flyctl status -a "$app_name" 2>&1 | grep -q "running"; then
                echo "‚úÖ Machine is running"

                # Additional check: can we execute a simple command?
                if timeout 15s flyctl ssh console -a "$app_name" -C "echo ready" &>/dev/null; then
                  echo "‚úÖ Machine is responsive"
                  return 0
                else
                  echo "‚ö†Ô∏è  Machine running but not responsive yet..."
                fi
              fi

              sleep 2
              attempt=$((attempt + 1))
            done

            echo "‚ùå Machine failed to become ready"
            return 1
          }

          export -f retry_with_backoff
          export -f flyctl_deploy_retry
          export -f ssh_command_retry
          export -f wait_for_machine_ready
          RETRY_EOF

          chmod +x /tmp/retry_utils.sh
          source /tmp/retry_utils.sh

          echo "‚úÖ Retry utilities configured"

      - name: Generate unique app name
        id: app-name
        run: |
          TIMESTAMP=$(date +%s)
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          APP_NAME="sindri-test-${SHORT_SHA}-${TIMESTAMP}"
          echo "app_name=${APP_NAME}" >> $GITHUB_OUTPUT
          echo "Generated app name: ${APP_NAME}"

      - name: Deploy VM with retry logic
        timeout-minutes: 10
        run: |
          source /tmp/retry_utils.sh

          echo "üöÄ Deploying test VM: ${{ steps.app-name.outputs.app_name }}"

          # Use flyctl_deploy_retry for resilient deployment
          if flyctl_deploy_retry "${{ steps.app-name.outputs.app_name }}"; then
            echo "‚úÖ Deployment completed"
          else
            echo "‚ùå Deployment failed after all retries"
            exit 1
          fi

      - name: Wait for machine readiness
        timeout-minutes: 5
        run: |
          source /tmp/retry_utils.sh

          if wait_for_machine_ready "${{ steps.app-name.outputs.app_name }}"; then
            echo "‚úÖ Machine ready for testing"
          else
            echo "‚ùå Machine failed readiness check"
            flyctl status -a "${{ steps.app-name.outputs.app_name }}" || true
            exit 1
          fi

      - name: Test SSH connectivity with retry
        timeout-minutes: 5
        run: |
          source /tmp/retry_utils.sh

          echo "üîç Testing SSH connectivity..."

          if ssh_command_retry "${{ steps.app-name.outputs.app_name }}" "echo 'SSH connection successful'"; then
            echo "‚úÖ SSH connectivity confirmed"
          else
            echo "‚ùå SSH connectivity test failed"
            exit 1
          fi

      - name: Test volume persistence with retry
        timeout-minutes: 5
        run: |
          source /tmp/retry_utils.sh

          echo "üîç Testing volume persistence..."

          # Write test data
          TEST_FILE="/workspace/test-persistence-$$"
          TEST_DATA="persistence-test-$(date +%s)"

          if ssh_command_retry "${{ steps.app-name.outputs.app_name }}" \
            "echo '$TEST_DATA' > $TEST_FILE && cat $TEST_FILE"; then
            echo "‚úÖ Volume write successful"
          else
            echo "‚ùå Volume write failed"
            exit 1
          fi

          # Restart machine
          echo "üîÑ Restarting machine..."
          MACHINE_ID=$(flyctl status -a "${{ steps.app-name.outputs.app_name }}" --json | jq -r '.Machines[0].id')

          if retry_with_backoff 3 5 30 flyctl machine restart "$MACHINE_ID" -a "${{ steps.app-name.outputs.app_name }}"; then
            echo "‚úÖ Machine restarted"
          else
            echo "‚ùå Machine restart failed"
            exit 1
          fi

          # Wait for machine to be ready again
          sleep 10
          wait_for_machine_ready "${{ steps.app-name.outputs.app_name }}"

          # Verify persistence
          echo "üîç Verifying data persistence..."
          if ssh_command_retry "${{ steps.app-name.outputs.app_name }}" \
            "test -f $TEST_FILE && cat $TEST_FILE | grep -q '$TEST_DATA'"; then
            echo "‚úÖ Volume persistence confirmed"
          else
            echo "‚ùå Volume persistence test failed"
            exit 1
          fi

      - name: Test extension system with retry
        timeout-minutes: 10
        run: |
          source /tmp/retry_utils.sh

          echo "üîç Testing extension system..."

          # Test extension-manager availability
          if ssh_command_retry "${{ steps.app-name.outputs.app_name }}" \
            "command -v extension-manager && extension-manager list"; then
            echo "‚úÖ Extension manager available"
          else
            echo "‚ùå Extension manager not found"
            exit 1
          fi

          # Test extension installation with retry
          echo "üîç Testing extension installation (nodejs)..."
          if retry_with_backoff 3 10 60 \
            flyctl ssh console -a "${{ steps.app-name.outputs.app_name }}" \
              -C "extension-manager install nodejs 2>&1"; then
            echo "‚úÖ Extension installation successful"
          else
            echo "‚ùå Extension installation failed"
            exit 1
          fi

          # Verify installation
          if ssh_command_retry "${{ steps.app-name.outputs.app_name }}" \
            "command -v node && node --version"; then
            echo "‚úÖ Extension validation successful"
          else
            echo "‚ùå Extension validation failed"
            exit 1
          fi

      - name: Cleanup test VM
        if: always()
        run: |
          source /tmp/retry_utils.sh

          echo "üßπ Cleaning up test VM..."

          if retry_with_backoff 3 5 30 \
            flyctl apps destroy "${{ steps.app-name.outputs.app_name }}" --yes; then
            echo "‚úÖ Test VM destroyed"
          else
            echo "‚ö†Ô∏è  Failed to destroy test VM (may require manual cleanup)"
          fi

      - name: Report test results
        if: always()
        run: |
          echo "üìä Test Summary"
          echo "=============="
          echo "App Name: ${{ steps.app-name.outputs.app_name }}"
          echo "Status: ${{ job.status }}"
          echo ""
          echo "All tests completed with comprehensive retry logic for:"
          echo "  - Flyctl deployments (4 attempts)"
          echo "  - SSH commands (5 attempts)"
          echo "  - Extension installations (3 attempts)"
          echo "  - Machine restarts (3 attempts)"
