name: Extension System Tests

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'docker/lib/extensions.d/**'
      - 'docker/lib/extension-manager.sh'
      - 'docker/lib/common.sh'
      - '.github/workflows/extension-tests.yml'
  pull_request:
    branches: [ main, develop ]
    paths:
      - 'docker/lib/extensions.d/**'
      - 'docker/lib/extension-manager.sh'
      - 'docker/lib/common.sh'
      - '.github/workflows/extension-tests.yml'
  workflow_dispatch:
    inputs:
      extension_name:
        description: 'Test specific extension (e.g., rust, golang, ai-tools)'
        required: false
        type: string
      skip_cleanup:
        description: 'Skip cleanup for debugging'
        required: false
        default: false
        type: boolean
      skip_idempotency:
        description: 'Skip idempotency tests (faster, but less thorough)'
        required: false
        default: false
        type: boolean

env:
  TEST_APP_PREFIX: "ext-test"
  REGION: "iad"
  FLY_API_TOKEN: ${{ secrets.FLYIO_AUTH_TOKEN }}

jobs:
  # ============================================================================
  # Job 1: Extension Manager Validation
  # ============================================================================
  extension-manager-validation:
    name: Validate Extension Manager
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Install shellcheck
        run: |
          sudo apt-get update
          sudo apt-get install -y shellcheck

      - name: Validate extension-manager.sh syntax
        run: |
          echo "Running shellcheck on extension-manager.sh..."
          shellcheck docker/lib/extension-manager.sh

      - name: Test extension-manager list command
        run: |
          echo "Testing extension-manager list command..."
          cd docker/lib
          bash extension-manager.sh list

      - name: Test extension name extraction
        run: |
          echo "Testing extension name extraction..."
          cd docker/lib

          # Test with various filename formats
          test_file="extensions.d/10-rust.sh.example"
          if [[ -f "$test_file" ]]; then
            # Extract name using the same logic as extension-manager
            name=$(basename "$test_file" .sh.example | sed 's/^[0-9]*-//')
            echo "Extracted name from $test_file: $name"

            if [[ "$name" != "rust" ]]; then
              echo "ERROR: Expected 'rust', got '$name'"
              exit 1
            fi
          fi

          echo "‚úÖ Extension name extraction working correctly"

      - name: Test protected extension detection
        run: |
          echo "Testing protected extension detection..."
          cd docker/lib

          # Create temporary test file
          touch extensions.d/00-test.sh.example

          # Test protected extension logic
          if bash -c 'source extension-manager.sh; is_protected_extension "00-test.sh" && echo "PROTECTED" || echo "NOT_PROTECTED"' | grep -q "PROTECTED"; then
            echo "‚úÖ Protected extension detection working"
          else
            echo "‚ùå Protected extension detection failed"
            exit 1
          fi

          # Cleanup
          rm -f extensions.d/00-test.sh.example

      - name: Report validation results
        if: always()
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            echo "‚úÖ Extension manager validation passed"
          else
            echo "‚ùå Extension manager validation failed"
          fi

  # ============================================================================
  # Job 2: Extension Syntax Validation
  # ============================================================================
  extension-syntax-validation:
    name: Validate Extension Scripts
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Install shellcheck
        run: |
          sudo apt-get update
          sudo apt-get install -y shellcheck

      - name: Validate all extension scripts
        run: |
          echo "Validating all extension scripts with shellcheck..."

          failed_scripts=()

          for script in docker/lib/extensions.d/*.sh.example docker/lib/extensions.d/*.sh; do
            # Skip if file doesn't exist (in case no .sh files)
            [[ ! -f "$script" ]] && continue

            echo "Checking $script..."
            if ! shellcheck -x "$script"; then
              failed_scripts+=("$script")
            fi
          done

          if [[ ${#failed_scripts[@]} -gt 0 ]]; then
            echo "‚ùå Shellcheck failed for:"
            printf '%s\n' "${failed_scripts[@]}"
            exit 1
          fi

          echo "‚úÖ All extension scripts pass shellcheck"

      - name: Verify common.sh sourcing
        run: |
          echo "Verifying all extensions source common.sh..."

          missing_source=()

          for script in docker/lib/extensions.d/*.sh.example; do
            [[ ! -f "$script" ]] && continue

            # Check if script sources common.sh
            if ! grep -q "source.*common\.sh" "$script"; then
              missing_source+=("$script")
            fi
          done

          if [[ ${#missing_source[@]} -gt 0 ]]; then
            echo "‚ö†Ô∏è  Extensions missing common.sh source:"
            printf '%s\n' "${missing_source[@]}"
            echo "This is a warning - extensions may have alternative sourcing"
          else
            echo "‚úÖ All extensions properly source common.sh"
          fi

      - name: Verify shebang presence
        run: |
          echo "Verifying all extensions have proper shebang..."

          missing_shebang=()

          for script in docker/lib/extensions.d/*.sh.example docker/lib/extensions.d/*.sh; do
            [[ ! -f "$script" ]] && continue

            # Check for shebang on first line
            if ! head -n 1 "$script" | grep -q "^#!/bin/bash"; then
              missing_shebang+=("$script")
            fi
          done

          if [[ ${#missing_shebang[@]} -gt 0 ]]; then
            echo "‚ùå Extensions missing proper shebang:"
            printf '%s\n' "${missing_shebang[@]}"
            exit 1
          fi

          echo "‚úÖ All extensions have proper shebang"

      - name: Check for error handling
        run: |
          echo "Checking for basic error handling patterns..."

          for script in docker/lib/extensions.d/*.sh.example; do
            [[ ! -f "$script" ]] && continue

            script_name=$(basename "$script")

            # Check if script uses print functions (good practice)
            if grep -q "print_" "$script"; then
              echo "‚úÖ $script_name uses print functions"
            else
              echo "‚ö†Ô∏è  $script_name doesn't use print functions"
            fi
          done

      - name: Report validation results
        if: always()
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            echo "‚úÖ Extension syntax validation passed"
          else
            echo "‚ùå Extension syntax validation failed"
          fi

  # ============================================================================
  # Job 3: Core Extension Tests (00-init.sh)
  # ============================================================================
  core-extension-tests:
    name: Test Core Extension (00-init.sh)
    runs-on: ubuntu-latest
    timeout-minutes: 45
    permissions:
      contents: read
    if: github.event_name != 'workflow_dispatch' || github.event.inputs.extension_name == ''

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Install Fly CLI
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Generate test app name
        id: app-name
        run: |
          timestamp=$(date +%s)
          app_name="${TEST_APP_PREFIX}-core-${timestamp}"
          echo "app_name=$app_name" >> $GITHUB_OUTPUT
          echo "Test app name: $app_name"

      - name: Create test SSH key
        run: |
          ssh-keygen -t ed25519 -f test_key -N "" -C "ext-test"
          chmod 600 test_key
          chmod 644 test_key.pub

      - name: Prepare fly.toml for testing
        env:
          APP_NAME: ${{ steps.app-name.outputs.app_name }}
          VOLUME_NAME: "test_data"
          VOLUME_SIZE: "5"
          VM_MEMORY: "2048"
          CPU_KIND: "shared"
          CPU_COUNT: "1"
          CI_MODE: "true"
        run: |
          ./scripts/prepare-fly-config.sh --ci-mode

      - name: Deploy test environment
        run: |
          echo "Creating Fly.io app for core extension testing..."

          flyctl apps create ${{ steps.app-name.outputs.app_name }} --org personal || echo "App may already exist"

          flyctl volumes create test_data \
            --app ${{ steps.app-name.outputs.app_name }} \
            --region ${REGION} \
            --size 5 \
            --no-encryption \
            --yes

          ssh_key_content=$(cat test_key.pub)
          flyctl secrets set AUTHORIZED_KEYS="$ssh_key_content" \
            --app ${{ steps.app-name.outputs.app_name }}
          flyctl secrets set CI_MODE="true" \
            --app ${{ steps.app-name.outputs.app_name }}

          # Deploy with retry logic
          max_attempts=3
          attempt=1
          while [ $attempt -le $max_attempts ]; do
            echo "Deployment attempt $attempt of $max_attempts..."
            if flyctl deploy --app ${{ steps.app-name.outputs.app_name }} --strategy immediate --wait-timeout 90s --yes; then
              echo "‚úÖ Deployment successful"
              break
            else
              if [ $attempt -lt $max_attempts ]; then
                wait_time=$((30 * attempt))
                echo "‚ö†Ô∏è  Deployment failed, retrying in ${wait_time}s..."
                sleep $wait_time
                attempt=$((attempt + 1))
              else
                echo "‚ùå Deployment failed after $max_attempts attempts"
                exit 1
              fi
            fi
          done

      - name: Wait for deployment
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"
          timeout=180
          elapsed=0
          interval=10

          while [ $elapsed -lt $timeout ]; do
            status_output=$(flyctl status --app $app_name 2>&1)
            echo "=== Status Check (${elapsed}s/${timeout}s) ==="

            if echo "$status_output" | grep -q "started"; then
              echo "‚úÖ Deployment successful"
              break
            elif echo "$status_output" | grep -q "failed\|crashed\|error"; then
              echo "‚ùå Deployment failed"
              exit 1
            fi

            sleep $interval
            elapsed=$((elapsed + interval))
          done

      - name: Verify core extension present
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          flyctl ssh console --app $app_name --command "/bin/bash -c '
            if [ -f /workspace/scripts/lib/extensions.d/00-init.sh ]; then
              echo \"‚úÖ Core extension 00-init.sh is present\"
              exit 0
            else
              echo \"‚ùå Core extension 00-init.sh is missing\"
              exit 1
            fi
          '"

      - name: Test core extension components
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          echo "Testing core extension components..."

          # Enhanced component testing with retry logic
          max_retries=2
          retry_count=0

          while [ $retry_count -lt $max_retries ]; do
            echo "Component test attempt $((retry_count + 1))/$max_retries..."

            if flyctl ssh console --app $app_name --command "/bin/bash -lc '
              # Load environment for non-interactive session
              if [ -f /etc/profile.d/00-ssh-environment.sh ]; then
                source /etc/profile.d/00-ssh-environment.sh
              fi

              echo \"=== Testing Turbo Flow Components ===\"
              component_failures=0

              # Check Playwright with timeout
              echo \"Checking Playwright...\"
              if timeout 30s npx playwright --version >/dev/null 2>&1; then
                version=\$(npx playwright --version 2>/dev/null || echo \"unknown\")
                echo \"‚úÖ Playwright installed: \$version\"
              else
                echo \"‚ùå Playwright not installed or not responding\"
                ((component_failures++))
              fi

              # Check TypeScript
              echo \"Checking TypeScript...\"
              if timeout 30s npx tsc --version >/dev/null 2>&1; then
                version=\$(npx tsc --version 2>/dev/null || echo \"unknown\")
                echo \"‚úÖ TypeScript installed: \$version\"
              else
                echo \"‚ùå TypeScript not installed or not responding\"
                ((component_failures++))
              fi

              # Check monitoring tools (optional)
              echo \"Checking monitoring tools...\"
              if command -v claude-monitor >/dev/null 2>&1; then
                echo \"‚úÖ claude-monitor available\"
              elif command -v uv >/dev/null 2>&1; then
                echo \"‚úÖ uv available\"
              else
                echo \"‚ö†Ô∏è  Optional monitoring tools not fully installed (non-critical)\"
              fi

              echo \"\"
              echo \"=== Testing Agent Manager ===\"

              # Check agent-manager binary with multiple possible locations
              echo \"Checking agent-manager binary...\"
              if [ -x /workspace/bin/agent-manager ]; then
                echo \"‚úÖ Agent Manager binary present at /workspace/bin/agent-manager\"
              elif [ -x /usr/local/bin/agent-manager ]; then
                echo \"‚úÖ Agent Manager binary present at /usr/local/bin/agent-manager\"
              elif command -v agent-manager >/dev/null 2>&1; then
                echo \"‚úÖ Agent Manager binary found in PATH: \$(command -v agent-manager)\"
              else
                echo \"‚ùå Agent Manager binary missing\"
                echo \"Searching for agent-manager...\"
                find /workspace /usr/local -name \"agent-manager\" -type f 2>/dev/null || true
                ((component_failures++))
              fi

              echo \"\"
              echo \"=== Testing Tmux Workspace ===\"

              # Check tmux installation
              echo \"Checking tmux...\"
              if command -v tmux >/dev/null 2>&1; then
                version=\$(tmux -V 2>/dev/null || echo \"unknown\")
                echo \"‚úÖ Tmux installed: \$version\"
              else
                echo \"‚ùå Tmux not installed\"
                ((component_failures++))
              fi

              # Check tmux config with multiple possible locations
              echo \"Checking tmux config...\"
              if [ -f /workspace/config/tmux.conf ]; then
                echo \"‚úÖ Tmux config present at /workspace/config/tmux.conf\"
              elif [ -f ~/.tmux.conf ]; then
                echo \"‚úÖ Tmux config present at ~/.tmux.conf\"
              else
                echo \"‚ö†Ô∏è  Tmux config not found (may use defaults)\"
              fi

              echo \"\"
              echo \"=== Testing Context Management ===\"

              # Check context loader with multiple possible locations
              echo \"Checking context loader...\"
              if [ -f /workspace/scripts/lib/context-loader.sh ]; then
                echo \"‚úÖ Context loader present at /workspace/scripts/lib/context-loader.sh\"
              elif [ -f /workspace/scripts/context-loader.sh ]; then
                echo \"‚úÖ Context loader present at /workspace/scripts/context-loader.sh\"
              else
                echo \"‚ùå Context loader missing\"
                echo \"Searching for context-loader.sh...\"
                find /workspace/scripts -name \"context-loader.sh\" -type f 2>/dev/null || true
                ((component_failures++))
              fi

              echo \"\"
              if [ \$component_failures -eq 0 ]; then
                echo \"‚úÖ All core extension components validated successfully\"
                exit 0
              else
                echo \"‚ùå \$component_failures component(s) failed validation\"
                exit 1
              fi
            '"; then
              echo "‚úÖ Core component tests passed"
              break
            else
              retry_count=$((retry_count + 1))
              if [ $retry_count -lt $max_retries ]; then
                echo "‚ö†Ô∏è  Component tests failed, retrying in 15s..."
                sleep 15
              else
                echo "‚ùå Core component tests failed after $max_retries attempts"
                exit 1
              fi
            fi
          done

      - name: Test protected extension behavior
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          echo "Testing that core extension cannot be deactivated..."
          flyctl ssh console --app $app_name --command "/bin/bash -c '
            cd /workspace/scripts/lib

            # Attempt to deactivate should fail
            if bash extension-manager.sh deactivate init --yes 2>&1 | grep -q \"Cannot deactivate protected\"; then
              echo \"‚úÖ Core extension properly protected from deactivation\"
              exit 0
            else
              echo \"‚ùå Core extension protection failed\"
              exit 1
            fi
          '"

      - name: Cleanup test resources
        if: always() && !inputs.skip_cleanup
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          machines=$(flyctl machine list --app $app_name --json | jq -r '.[].id')
          for machine in $machines; do
            flyctl machine stop $machine --app $app_name || true
            sleep 5
            flyctl machine destroy $machine --app $app_name --force || true
          done

          volumes=$(flyctl volumes list --app $app_name --json | jq -r '.[].id')
          for volume in $volumes; do
            flyctl volumes destroy $volume --app $app_name --yes || true
          done

          flyctl apps destroy $app_name --yes || true
          rm -f test_key test_key.pub

  # ============================================================================
  # Job 4: Per-Extension Tests (Matrix)
  # ============================================================================
  per-extension-tests:
    name: Test Extension - ${{ matrix.extension.name }}
    runs-on: ubuntu-latest
    timeout-minutes: 60
    permissions:
      contents: read

    strategy:
      fail-fast: false
      matrix:
        extension:
          - { name: 'rust', commands: 'rustc,cargo', key_tool: 'rustc', timeout: '30m' }
          - { name: 'golang', commands: 'go', key_tool: 'go', timeout: '30m' }
          - { name: 'python', commands: 'python3,pip3', key_tool: 'python3', timeout: '30m' }
          - { name: 'docker', commands: 'docker', key_tool: 'docker', timeout: '30m' }
          - { name: 'jvm', commands: 'java,sdk', key_tool: 'java', timeout: '30m' }
          - { name: 'php', commands: 'php,composer', key_tool: 'php', timeout: '30m' }
          - { name: 'ruby', commands: 'ruby,gem,bundle', key_tool: 'ruby', timeout: '30m' }
          - { name: 'dotnet', commands: 'dotnet', key_tool: 'dotnet', timeout: '30m' }
          - { name: 'infra-tools', commands: 'terraform,ansible', key_tool: 'terraform', timeout: '30m' }
          - { name: 'cloud-tools', commands: 'aws', key_tool: 'aws', timeout: '30m' }
          - { name: 'ai-tools', commands: 'ollama,fabric', key_tool: 'ollama', timeout: '30m' }

    steps:
      - name: Check if extension should be tested
        id: should-test
        run: |
          # Skip if workflow_dispatch with specific extension that doesn't match
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && \
             [ -n "${{ github.event.inputs.extension_name }}" ] && \
             [ "${{ github.event.inputs.extension_name }}" != "${{ matrix.extension.name }}" ]; then
            echo "should_test=false" >> $GITHUB_OUTPUT
            echo "Skipping ${{ matrix.extension.name }} - not requested"
          else
            echo "should_test=true" >> $GITHUB_OUTPUT
            echo "Testing ${{ matrix.extension.name }}"
          fi

      - name: Checkout code
        if: steps.should-test.outputs.should_test == 'true'
        uses: actions/checkout@v5

      - name: Install Fly CLI
        if: steps.should-test.outputs.should_test == 'true'
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Generate test app name
        if: steps.should-test.outputs.should_test == 'true'
        id: app-name
        run: |
          timestamp=$(date +%s)
          app_name="${TEST_APP_PREFIX}-${{ matrix.extension.name }}-${timestamp}"
          echo "app_name=$app_name" >> $GITHUB_OUTPUT
          echo "Test app name: $app_name"

      - name: Create test SSH key
        if: steps.should-test.outputs.should_test == 'true'
        run: |
          ssh-keygen -t ed25519 -f test_key -N "" -C "ext-test"
          chmod 600 test_key
          chmod 644 test_key.pub

      - name: Prepare fly.toml for testing
        if: steps.should-test.outputs.should_test == 'true'
        env:
          APP_NAME: ${{ steps.app-name.outputs.app_name }}
          VOLUME_NAME: "test_data"
          VOLUME_SIZE: "10"
          VM_MEMORY: "4096"
          CPU_KIND: "shared"
          CPU_COUNT: "2"
          CI_MODE: "true"
        run: |
          ./scripts/prepare-fly-config.sh --ci-mode

      - name: Deploy test environment
        if: steps.should-test.outputs.should_test == 'true'
        run: |
          echo "Deploying test environment for ${{ matrix.extension.name }}..."

          flyctl apps create ${{ steps.app-name.outputs.app_name }} --org personal || echo "App may already exist"

          flyctl volumes create test_data \
            --app ${{ steps.app-name.outputs.app_name }} \
            --region ${REGION} \
            --size 10 \
            --no-encryption \
            --yes

          ssh_key_content=$(cat test_key.pub)
          flyctl secrets set AUTHORIZED_KEYS="$ssh_key_content" \
            --app ${{ steps.app-name.outputs.app_name }}
          flyctl secrets set CI_MODE="true" \
            --app ${{ steps.app-name.outputs.app_name }}

          # Deploy with retry logic
          max_attempts=3
          attempt=1
          while [ $attempt -le $max_attempts ]; do
            echo "Deployment attempt $attempt of $max_attempts..."
            if flyctl deploy --app ${{ steps.app-name.outputs.app_name }} --strategy immediate --wait-timeout 120s --yes; then
              echo "‚úÖ Deployment successful"
              break
            else
              if [ $attempt -lt $max_attempts ]; then
                wait_time=$((30 * attempt))
                echo "‚ö†Ô∏è  Deployment failed, retrying in ${wait_time}s..."
                sleep $wait_time
                attempt=$((attempt + 1))
              else
                echo "‚ùå Deployment failed after $max_attempts attempts"
                exit 1
              fi
            fi
          done

      - name: Wait for deployment
        if: steps.should-test.outputs.should_test == 'true'
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"
          timeout=240
          elapsed=0
          interval=15

          while [ $elapsed -lt $timeout ]; do
            status_output=$(flyctl status --app $app_name 2>&1)

            if echo "$status_output" | grep -q "started"; then
              echo "‚úÖ Deployment successful"
              sleep 30  # Extra time for system to stabilize
              break
            elif echo "$status_output" | grep -q "failed\|crashed\|error"; then
              echo "‚ùå Deployment failed"
              flyctl logs --app $app_name
              exit 1
            fi

            sleep $interval
            elapsed=$((elapsed + interval))
          done

      - name: Activate extension
        if: steps.should-test.outputs.should_test == 'true'
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"
          extension_name="${{ matrix.extension.name }}"

          echo "Activating $extension_name extension..."
          flyctl ssh console --app $app_name --command "/bin/bash -c '
            cd /workspace/scripts/lib
            if bash extension-manager.sh activate $extension_name; then
              echo \"‚úÖ Extension activated successfully\"
            else
              echo \"‚ùå Extension activation failed\"
              exit 1
            fi
          '"

      - name: Run vm-configure with extension
        if: steps.should-test.outputs.should_test == 'true'
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"
          timeout="${{ matrix.extension.timeout }}"

          echo "Running vm-configure.sh with ${{ matrix.extension.name }} extension (timeout: $timeout)..."

          # Enhanced configuration with better error handling and timeout management
          max_config_attempts=2
          config_attempt=1

          while [ $config_attempt -le $max_config_attempts ]; do
            echo "Configuration attempt $config_attempt/$max_config_attempts..."

            if flyctl ssh console --app $app_name --command "/bin/bash -c '
              echo \"=== Starting extension installation ===\"
              echo \"Extension: ${{ matrix.extension.name }}\"
              echo \"Timeout: $timeout\"
              echo \"\"

              # Run with enhanced timeout and logging
              if timeout --kill-after=60s $timeout /workspace/scripts/vm-configure.sh --extensions-only 2>&1 | tee /tmp/configure.log; then
                config_exit_code=\${PIPESTATUS[0]}

                if [ \$config_exit_code -eq 0 ]; then
                  echo \"\"
                  echo \"‚úÖ Configuration completed successfully\"
                  echo \"\"

                  # Verify configuration success markers
                  if grep -q \"Extension setup completed\" /tmp/configure.log || \
                     grep -q \"Configuration complete\" /tmp/configure.log; then
                    echo \"‚úÖ Configuration markers found\"
                  else
                    echo \"‚ö†Ô∏è  No completion markers found, but no errors detected\"
                  fi

                  # Wait for SSH daemon reload to settle
                  echo \"‚è≥ Waiting for SSH environment to stabilize (15 seconds)...\"
                  sleep 15

                  # Verify SSH environment is properly configured
                  if [ -f /etc/profile.d/00-ssh-environment.sh ]; then
                    echo \"‚úÖ SSH environment file present\"
                  else
                    echo \"‚ö†Ô∏è  SSH environment file not found\"
                  fi

                  exit 0
                else
                  echo \"\"
                  echo \"‚ùå Configuration exited with code: \$config_exit_code\"
                  echo \"Last 30 lines of output:\"
                  tail -30 /tmp/configure.log
                  exit 1
                fi
              else
                timeout_exit_code=\$?
                echo \"\"

                if [ \$timeout_exit_code -eq 124 ]; then
                  echo \"‚ùå Configuration timed out after $timeout\"
                elif [ \$timeout_exit_code -eq 137 ]; then
                  echo \"‚ùå Configuration was killed (timeout kill signal)\"
                else
                  echo \"‚ùå Configuration failed with exit code: \$timeout_exit_code\"
                fi

                echo \"\"
                echo \"Last 50 lines of output:\"
                tail -50 /tmp/configure.log

                # Check for specific error patterns
                echo \"\"
                echo \"=== Error Analysis ===\"
                if grep -i \"error\|failed\|timeout\" /tmp/configure.log | tail -10; then
                  echo \"(Errors found in log)\"
                else
                  echo \"No obvious errors in log\"
                fi

                exit 1
              fi
            '"; then
              echo "‚úÖ vm-configure.sh completed successfully"
              break
            else
              exit_code=$?
              config_attempt=$((config_attempt + 1))

              if [ $config_attempt -le $max_config_attempts ]; then
                echo "‚ö†Ô∏è  Configuration attempt failed with exit code $exit_code"
                echo "Checking app status before retry..."
                flyctl status --app $app_name || true
                echo "Waiting 30s before retry..."
                sleep 30
              else
                echo "‚ùå vm-configure.sh failed after $max_config_attempts attempts"
                echo "Retrieving app logs for diagnosis..."
                flyctl logs --app $app_name
                exit 1
              fi
            fi
          done

      - name: Verify commands available
        if: steps.should-test.outputs.should_test == 'true'
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"
          commands="${{ matrix.extension.commands }}"

          echo "Verifying commands are available: $commands"

          # Enhanced verification with retry logic and better error handling
          max_retries=3
          retry_count=0

          while [ $retry_count -lt $max_retries ]; do
            echo "Verification attempt $((retry_count + 1))/$max_retries..."

            if flyctl ssh console --app $app_name --command "/bin/bash -lc '
              # Source environment to ensure all paths are loaded
              if [ -f /etc/profile.d/00-ssh-environment.sh ]; then
                source /etc/profile.d/00-ssh-environment.sh
              fi

              # Additional environment setup for non-interactive sessions
              if [ -f ~/.bashrc ]; then
                source ~/.bashrc
              fi

              commands=\"$commands\"
              IFS=\",\" read -ra CMD_ARRAY <<< \"\$commands\"
              failed_commands=()

              echo \"=== Command Verification ===\"
              echo \"Current PATH: \$PATH\"
              echo \"\"

              for cmd in \"\${CMD_ARRAY[@]}\"; do
                echo \"Checking command: \$cmd\"

                # Try multiple methods to find the command
                if command -v \"\$cmd\" >/dev/null 2>&1; then
                  echo \"‚úÖ \$cmd available at: \$(command -v \"\$cmd\")\"
                  \"\$cmd\" --version 2>/dev/null || \"\$cmd\" version 2>/dev/null || echo \"  (version check not supported)\"
                elif which \"\$cmd\" >/dev/null 2>&1; then
                  echo \"‚úÖ \$cmd available at: \$(which \"\$cmd\")\"
                  \"\$cmd\" --version 2>/dev/null || \"\$cmd\" version 2>/dev/null || echo \"  (version check not supported)\"
                elif [ -x \"/usr/local/bin/\$cmd\" ]; then
                  echo \"‚úÖ \$cmd available at: /usr/local/bin/\$cmd\"
                  \"/usr/local/bin/\$cmd\" --version 2>/dev/null || echo \"  (version check not supported)\"
                else
                  echo \"‚ùå \$cmd not found in PATH\"
                  echo \"  Searching for \$cmd...\"
                  find /usr/local /opt /home -name \"\$cmd\" -type f 2>/dev/null | head -5 || true
                  failed_commands+=(\"\$cmd\")
                fi
                echo \"\"
              done

              if [ \${#failed_commands[@]} -gt 0 ]; then
                echo \"‚ùå Missing commands: \${failed_commands[*]}\"
                echo \"\"
                echo \"=== Debug Info ===\"
                echo \"Available executables in common locations:\"
                ls -la /usr/local/bin/ 2>/dev/null | head -20 || true
                echo \"\"
                echo \"Environment variables:\"
                env | grep -E \"PATH|HOME|USER\" || true
                exit 1
              fi

              echo \"‚úÖ All commands available and verified\"
            '"; then
              echo "‚úÖ Command verification successful"
              break
            else
              retry_count=$((retry_count + 1))
              if [ $retry_count -lt $max_retries ]; then
                wait_time=$((10 * retry_count))
                echo "‚ö†Ô∏è  Verification failed, retrying in ${wait_time}s..."
                sleep $wait_time
              else
                echo "‚ùå Command verification failed after $max_retries attempts"
                exit 1
              fi
            fi
          done

      - name: Diagnose environment on failure
        if: failure() && steps.should-test.outputs.should_test == 'true'
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          echo "üîç Comprehensive environment diagnostics for debugging..."
          flyctl ssh console --app $app_name --command "/bin/bash -lc '
            echo \"===========================================\"
            echo \"   ENVIRONMENT DIAGNOSTICS\"
            echo \"===========================================\"
            echo \"\"

            echo \"=== Basic System Information ===\"
            echo \"Current user: \$(whoami)\"
            echo \"User home: \$HOME\"
            echo \"Current directory: \$(pwd)\"
            echo \"Shell: \$SHELL\"
            echo \"\"

            echo \"=== PATH Configuration ===\"
            echo \"Current PATH:\"
            echo \"\$PATH\" | tr \":\" \"\\n\" | nl
            echo \"\"

            echo \"=== Environment Variables ===\"
            echo \"BASH_ENV: \$BASH_ENV\"
            echo \"CI_MODE: \$CI_MODE\"
            env | grep -E \"PATH|HOME|USER|SHELL|BASH\" | sort
            echo \"\"

            echo \"=== Profile and RC Files ===\"
            for file in /etc/profile ~/.profile ~/.bashrc ~/.bash_profile; do
              if [ -f \"\$file\" ]; then
                echo \"‚úÖ \$file exists\"
              else
                echo \"‚ùå \$file not found\"
              fi
            done
            echo \"\"

            echo \"=== Profile.d Scripts ===\"
            if [ -d /etc/profile.d/ ]; then
              ls -lh /etc/profile.d/
              echo \"\"
              for script in /etc/profile.d/*.sh; do
                if [ -f \"\$script\" ]; then
                  echo \"Content of \$(basename \$script) (first 15 lines):\"
                  head -15 \"\$script\"
                  echo \"---\"
                fi
              done
            else
              echo \"‚ùå /etc/profile.d/ directory not found\"
            fi
            echo \"\"

            echo \"=== SSH Environment Configuration ===\"
            if [ -f /etc/profile.d/00-ssh-environment.sh ]; then
              echo \"‚úÖ SSH environment file exists\"
              echo \"Full content:\"
              cat /etc/profile.d/00-ssh-environment.sh
            else
              echo \"‚ùå SSH environment file not found\"
            fi
            echo \"\"

            echo \"=== SSH Daemon Configuration ===\"
            if [ -f /etc/ssh/sshd_config.d/99-bash-env.conf ]; then
              echo \"‚úÖ SSH daemon env config exists\"
              cat /etc/ssh/sshd_config.d/99-bash-env.conf
            else
              echo \"‚ùå SSH daemon env config not found\"
            fi
            echo \"\"

            echo \"=== Extension Manager Status ===\"
            if [ -f /workspace/scripts/lib/extension-manager.sh ]; then
              echo \"‚úÖ Extension manager found\"
              cd /workspace/scripts/lib && bash extension-manager.sh list
            else
              echo \"‚ùå Extension manager not found\"
            fi
            echo \"\"

            echo \"=== Active Extensions ===\"
            if [ -d /workspace/scripts/extensions.d ]; then
              echo \"Activated extensions:\"
              ls -lh /workspace/scripts/extensions.d/*.sh 2>/dev/null || echo \"No active extensions\"
            elif [ -d /workspace/scripts/lib/extensions.d ]; then
              echo \"Activated extensions:\"
              ls -lh /workspace/scripts/lib/extensions.d/*.sh 2>/dev/null || echo \"No active extensions\"
            else
              echo \"‚ùå Extensions directory not found\"
            fi
            echo \"\"

            echo \"=== Installed Tools and Wrappers ===\"
            echo \"Tools in /usr/local/bin:\"
            ls -lh /usr/local/bin/ 2>/dev/null | grep -E \"(go|cargo|rustc|ruby|java|sdk|python|php|docker|terraform|aws|ollama)\" || echo \"No tool wrappers found\"
            echo \"\"

            echo \"=== Tool Version Checks ===\"
            for tool in go cargo rustc ruby java python3 php docker terraform aws ollama; do
              echo -n \"Checking \$tool: \"
              if command -v \$tool >/dev/null 2>&1; then
                echo \"Found at \$(command -v \$tool)\"
                \$tool --version 2>/dev/null || \$tool version 2>/dev/null || echo \"  (version check not supported)\"
              else
                echo \"Not found in PATH\"
              fi
            done
            echo \"\"

            echo \"=== Recent Configuration Logs ===\"
            if [ -f /tmp/configure.log ]; then
              echo \"Last 100 lines of configuration log:\"
              tail -100 /tmp/configure.log
            else
              echo \"No configuration log found\"
            fi
            echo \"\"

            echo \"=== System Resources ===\"
            echo \"Disk usage:\"
            df -h / /workspace 2>/dev/null || true
            echo \"\"
            echo \"Memory usage:\"
            free -h 2>/dev/null || true
            echo \"\"

            echo \"===========================================\"
            echo \"   END DIAGNOSTICS\"
            echo \"===========================================\"
          '" || echo "‚ö†Ô∏è  Failed to retrieve full diagnostics"

          echo ""
          echo "Retrieving application logs..."
          flyctl logs --app $app_name || echo "Failed to retrieve logs"

      - name: Test key functionality
        if: steps.should-test.outputs.should_test == 'true'
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"
          key_tool="${{ matrix.extension.key_tool }}"

          echo "Testing key functionality for $key_tool..."

          flyctl ssh console --app $app_name --command "/bin/bash -c '
            case \"$key_tool\" in
              rustc)
                echo \"Testing Rust compilation...\"
                echo \"fn main() { println!(\\\"Hello\\\"); }\" > /tmp/test.rs
                rustc /tmp/test.rs -o /tmp/test && /tmp/test
                ;;
              go)
                echo \"Testing Go compilation...\"
                echo \"package main; import \\\"fmt\\\"; func main() { fmt.Println(\\\"Hello\\\") }\" > /tmp/test.go
                go run /tmp/test.go
                ;;
              python3)
                echo \"Testing Python execution...\"
                python3 -c \"print('Hello')\"
                pip3 --version
                ;;
              java)
                echo \"Testing Java...\"
                java -version
                ;;
              php)
                echo \"Testing PHP...\"
                php -r \"echo 'Hello';\"
                ;;
              ruby)
                echo \"Testing Ruby...\"
                ruby -e \"puts 'Hello'\"
                ;;
              dotnet)
                echo \"Testing .NET...\"
                dotnet --info
                ;;
              docker)
                echo \"Testing Docker...\"
                docker --version
                docker-compose --version || docker compose version
                ;;
              terraform)
                echo \"Testing Terraform...\"
                terraform version
                ;;
              aws)
                echo \"Testing AWS CLI...\"
                aws --version
                ;;
              ollama)
                echo \"Testing Ollama...\"
                ollama --version
                ;;
              *)
                echo \"‚ö†Ô∏è  No specific test for $key_tool\"
                ;;
            esac

            echo \"‚úÖ Key functionality test passed\"
          '"

      - name: Test idempotency
        if: steps.should-test.outputs.should_test == 'true' && inputs.skip_idempotency != true
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          echo "Testing idempotency (running vm-configure.sh again)..."

          flyctl ssh console --app $app_name --command "/bin/bash -c '
            echo \"Running configuration a second time...\"
            if /workspace/scripts/vm-configure.sh --extensions-only 2>&1 | tee /tmp/configure2.log; then
              # Check for error indicators in output
              if grep -qi \"error\|failed\" /tmp/configure2.log; then
                echo \"‚ö†Ô∏è  Warnings or errors detected on second run\"
                grep -i \"error\|failed\" /tmp/configure2.log || true
              else
                echo \"‚úÖ Second run completed without errors\"
              fi
            else
              echo \"‚ùå Second run failed\"
              exit 1
            fi
          '"

      - name: Cleanup test resources
        if: always() && !inputs.skip_cleanup
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          machines=$(flyctl machine list --app $app_name --json 2>/dev/null | jq -r '.[].id' || echo "")
          for machine in $machines; do
            [[ -z "$machine" ]] && continue
            flyctl machine stop $machine --app $app_name || true
            sleep 3
            flyctl machine destroy $machine --app $app_name --force || true
          done

          volumes=$(flyctl volumes list --app $app_name --json 2>/dev/null | jq -r '.[].id' || echo "")
          for volume in $volumes; do
            [[ -z "$volume" ]] && continue
            flyctl volumes destroy $volume --app $app_name --yes || true
          done

          flyctl apps destroy $app_name --yes || true
          rm -f test_key test_key.pub

  # ============================================================================
  # Job 5: Extension Combinations
  # ============================================================================
  extension-combinations:
    name: Test Combination - ${{ matrix.combination.name }}
    runs-on: ubuntu-latest
    timeout-minutes: 90
    permissions:
      contents: read
    # Only run on workflow_dispatch or when explicitly requested via commit message
    if: github.event_name == 'workflow_dispatch' || contains(github.event.head_commit.message, '[test-combinations]')

    strategy:
      fail-fast: false
      matrix:
        combination:
          - { name: 'fullstack', extensions: 'python,docker,cloud-tools', description: 'Python + Docker + Cloud' }
          - { name: 'systems', extensions: 'rust,golang,docker', description: 'Rust + Go + Docker' }
          - { name: 'enterprise', extensions: 'jvm,docker,infra-tools', description: 'JVM + Docker + Infrastructure' }
          - { name: 'ai-dev', extensions: 'python,ai-tools,docker', description: 'Python + AI Tools + Docker' }

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Install Fly CLI
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Generate test app name
        id: app-name
        run: |
          timestamp=$(date +%s)
          app_name="${TEST_APP_PREFIX}-combo-${{ matrix.combination.name }}-${timestamp}"
          echo "app_name=$app_name" >> $GITHUB_OUTPUT

      - name: Create test SSH key
        run: |
          ssh-keygen -t ed25519 -f test_key -N "" -C "ext-test"
          chmod 600 test_key
          chmod 644 test_key.pub

      - name: Prepare fly.toml for testing
        env:
          APP_NAME: ${{ steps.app-name.outputs.app_name }}
          VOLUME_NAME: "test_data"
          VOLUME_SIZE: "15"
          VM_MEMORY: "8192"
          CPU_KIND: "shared"
          CPU_COUNT: "4"
          CI_MODE: "true"
        run: |
          ./scripts/prepare-fly-config.sh --ci-mode

      - name: Deploy test environment
        run: |
          flyctl apps create ${{ steps.app-name.outputs.app_name }} --org personal || true

          flyctl volumes create test_data \
            --app ${{ steps.app-name.outputs.app_name }} \
            --region ${REGION} \
            --size 15 \
            --no-encryption \
            --yes

          ssh_key_content=$(cat test_key.pub)
          flyctl secrets set AUTHORIZED_KEYS="$ssh_key_content" \
            --app ${{ steps.app-name.outputs.app_name }}
          flyctl secrets set CI_MODE="true" \
            --app ${{ steps.app-name.outputs.app_name }}

          # Deploy with retry logic
          max_attempts=3
          attempt=1
          while [ $attempt -le $max_attempts ]; do
            echo "Deployment attempt $attempt of $max_attempts..."
            if flyctl deploy --app ${{ steps.app-name.outputs.app_name }} --strategy immediate --wait-timeout 180s --yes; then
              echo "‚úÖ Deployment successful"
              break
            else
              if [ $attempt -lt $max_attempts ]; then
                wait_time=$((30 * attempt))
                echo "‚ö†Ô∏è  Deployment failed, retrying in ${wait_time}s..."
                sleep $wait_time
                attempt=$((attempt + 1))
              else
                echo "‚ùå Deployment failed after $max_attempts attempts"
                exit 1
              fi
            fi
          done

      - name: Wait for deployment
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"
          timeout=300
          elapsed=0
          interval=20

          while [ $elapsed -lt $timeout ]; do
            status_output=$(flyctl status --app $app_name 2>&1)

            if echo "$status_output" | grep -q "started"; then
              echo "‚úÖ Deployment successful"
              sleep 45
              break
            fi

            sleep $interval
            elapsed=$((elapsed + interval))
          done

      - name: Activate extension combination
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"
          extensions="${{ matrix.combination.extensions }}"

          echo "Activating extensions: $extensions"

          IFS=',' read -ra EXT_ARRAY <<< "$extensions"

          flyctl ssh console --app $app_name --command "/bin/bash -c '
            cd /workspace/scripts/lib
            failed_extensions=()

            for ext in ${EXT_ARRAY[@]}; do
              echo \"Activating: \$ext\"
              if bash extension-manager.sh activate \$ext; then
                echo \"‚úÖ \$ext activated\"
              else
                echo \"‚ùå \$ext activation failed\"
                failed_extensions+=(\"\$ext\")
              fi
            done

            if [ \${#failed_extensions[@]} -gt 0 ]; then
              echo \"‚ùå Failed to activate: \${failed_extensions[*]}\"
              exit 1
            fi

            echo \"‚úÖ All extensions activated\"
          '"

      - name: Run vm-configure with extensions
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          echo "Running vm-configure.sh with extension combination..."

          flyctl ssh console --app $app_name --command "/bin/bash -c '
            if timeout 60m /workspace/scripts/vm-configure.sh --extensions-only 2>&1 | tee /tmp/configure-combo.log; then
              echo \"‚úÖ Configuration completed\"
            else
              echo \"‚ùå Configuration failed\"
              tail -100 /tmp/configure-combo.log
              exit 1
            fi
          '"

      - name: Verify no conflicts
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          echo "Checking for conflicts or errors..."

          flyctl ssh console --app $app_name --command "/bin/bash -c '
            if [ -f /tmp/configure-combo.log ]; then
              # Check for common conflict indicators
              if grep -qi \"conflict\|collision\|duplicate\" /tmp/configure-combo.log; then
                echo \"‚ö†Ô∏è  Potential conflicts detected\"
                grep -i \"conflict\|collision\|duplicate\" /tmp/configure-combo.log
              else
                echo \"‚úÖ No conflicts detected\"
              fi
            fi
          '"

      - name: Test cross-extension functionality
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"
          combo="${{ matrix.combination.name }}"

          echo "Testing cross-extension functionality for $combo..."

          flyctl ssh console --app $app_name --command "/bin/bash -c '
            case \"$combo\" in
              fullstack)
                echo \"Testing Python + Docker combination...\"
                python3 --version && docker --version
                ;;
              systems)
                echo \"Testing Rust + Go combination...\"
                rustc --version && go version
                ;;
              enterprise)
                echo \"Testing JVM + Infrastructure combination...\"
                java -version && terraform version
                ;;
              ai-dev)
                echo \"Testing Python + AI Tools combination...\"
                python3 --version && ollama --version
                ;;
            esac

            echo \"‚úÖ Cross-extension functionality verified\"
          '"

      - name: Cleanup test resources
        if: always() && !inputs.skip_cleanup
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          machines=$(flyctl machine list --app $app_name --json 2>/dev/null | jq -r '.[].id' || echo "")
          for machine in $machines; do
            [[ -z "$machine" ]] && continue
            flyctl machine stop $machine --app $app_name || true
            sleep 3
            flyctl machine destroy $machine --app $app_name --force || true
          done

          volumes=$(flyctl volumes list --app $app_name --json 2>/dev/null | jq -r '.[].id' || echo "")
          for volume in $volumes; do
            [[ -z "$volume" ]] && continue
            flyctl volumes destroy $volume --app $app_name --yes || true
          done

          flyctl apps destroy $app_name --yes || true
          rm -f test_key test_key.pub

  # ============================================================================
  # Job 6: Report Test Results
  # ============================================================================
  report-results:
    name: Report Test Results
    runs-on: ubuntu-latest
    needs: [extension-manager-validation, extension-syntax-validation, core-extension-tests]
    if: always()
    permissions:
      contents: read

    steps:
      - name: Generate test report
        run: |
          echo "# Extension System Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Job Status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- Extension Manager Validation: ${{ needs.extension-manager-validation.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- Extension Syntax Validation: ${{ needs.extension-syntax-validation.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- Core Extension Tests: ${{ needs.core-extension-tests.result }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ needs.extension-manager-validation.result }}" = "success" ] && \
             [ "${{ needs.extension-syntax-validation.result }}" = "success" ] && \
             [ "${{ needs.core-extension-tests.result }}" = "success" ]; then
            echo "‚úÖ **All critical tests passed**" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Some tests failed - review logs above**" >> $GITHUB_STEP_SUMMARY
          fi
